# ANDROID-APP-FibonacciNumbersGetter
Первое приложение на android.
---
Введя n - порядковый номер числа фибоначчи, можно получить его значение.   
Программа поддерживает 0 <= n <= 92. При n=93 происходит переполнение типа long, да и числа получаются настолько огроменными, что их становится трудно вмещать на экране.   

# Что реализовано?    
> * Валидатор ввода чисел, с подсветкой. Допускает только целые числа от 0 до 92 включительно. При этом для 0 значение числа фибоначчи пологаем = 0. При наборе каких-либо других символов с клавиатуры или выходе за диапазоны, валидатор будет подсвечивать поле ввода красным и показывать всплывающие подсказки.   
> * Вообще, можно было бы задать у editText принимаемый тип "numbers", тогда отпала бы необходимость в реализованном мною валидаторе. Я оставил возможность ввода произвольного текста лишь для демонстрации работы валидатора, разработанного мною, который обрабатывает посимвольные изменения у editText.   
> * Два активити. Первое - MainActivity, второе - AnswerActivity. В первом вводятся данные и работает валидатор. Если введены корректные данные, то при нажатии на кнопку данные передаются в вызываемое второе активити.   
> * Во втором активити осуществляется прием данных из первого активити, и, в отдельном потоке, реализованном с помощью пакета io.reactivex.schedulers.Schedulers производится вычисление числа fib(n). Размер выдаваемых значений соответствует типу long, что соответствует до 92го числа фибоначчи включительно. Результат работы нового потока возвращается в старый поток UI, откуда второе активити принимает результат и выводит его на экран (или значение ошибки, если такая возникнет). Я предусмотрел все возможные варианты ошибок (о которых смог догадаться) и принял меры по их обработке. Хотя по реализованной логике, эти ошибки в принципе не должны произойти благодаря реализованному валидатору.   
Выбор этого пакета для реализации многопоточности имеет приемущества перед такими методами, как Thread и AsyncTask:   
удалятся ссылки на текущее активити, его контекст, решится проблема утечки памяти благодаря уничтожению потока в переопределенном методе onDestroy().   
> * Реализована возможность из второго активити вернуться на первое и повторить операции.   
> * Старался избегать задание цветов и строк "прямо в коде", а реализовал через константы. Все используемые в программе цвета и строки определил в res/values/strings, res/values/colors.   
> * Отключил возможность горизонтального поворота экранов активностей.   
> * Добавил иконку для приложения.   


